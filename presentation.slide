# All Types of Go Types

GoWest 2020

Carson Anderson
DevX Engineer, Weave
@carson_ops

## Questions I Had About Go Types

* How big is a bool?
* How big is an `int`?
* What type is a `constant`?s
* How big is an empty `struct`?
* What type is a `LABEL`?
* Are all `nil`s identical?
* What happens when I pass a `slice`?
* When should I pass a `struct` vs `pointer`?

## How big is a bool?

: We are starting simple, but this shows that even seemingly easy assumptions can be wrong

A seemingly simple question

.play examples/bool.go /^func main/,/^}

: Size is not what is expected

## Makes sense... Except!

: Explain reflect.SizeOf since we will use it a lot

From the Go docs on `reflect.SizeOf`:

.code examples/bool.go /START OMIT/,/END OMIT/

: Size is not what is expected

So really...

.play examples/bool-bits.go /^func main/,/^}

## Interesting Golang Type Discoveriess

1. Bools can be **more than one bit**

## IntXX Types

: count from source using 'git ls-files | xargs -n1 grep -Iswo int | wc -l'
: it's a rought calculation, but good enough to illustrate the point
: call out that the int type is used far more than any other type

.html /html/ints.html

Plain old `int` is the most used integer type by far.

## intXX Size Proof

.play examples/ints.go /^func main/,/^}

## uintXX Size Proof

.play examples/uints.go /^func main/,/^}

## But what about plain old `int`?

.play examples/int.go /^func main/,/^}

That answers it, right!

 .. Right?

What if I do this?

`
GOARCH=386 go run examples/int.go
`

## int and uint size in Go is implementation-specific

* 32 bit for 32 bit systems
* 64 bit for 64 bit systems

So.. Which one do I use?

* int is suggested for most cases
* intXX for data int for everything else

## Interesting Golang Type Discoveriess

1. Bools can be **more than one bit**
1. `int` and `uint` can **change size**

## A Note on Sizes

The architecture size is also called "word" length

* There will be many other cases where variable sizes change based
on word length
* All of the examples and size here are for `GOARCH=amd64` an 8 byte (64 bit) word length

## Floats

Talk about `floatXX` constants vs variables and `==` behavior

.play examples/floats.go /^func main/,/^}

## Float Math - Variables

Float variables have arbitrary precision

.play examples/floats-math-vars.go /^func main/,/^}

## Float Math - Constants

.play examples/floats-math-const.go /^func main/,/^}

## But how?

.link https://golang.org/ref/spec#Constants

> Implementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision

.code examples/floats-math-const.go /^func main/,/^}

## Interesting Golang Type Discoveriess

1. Bools can be **more than one bit**
1. `int` and `uint` can **change size**
1. Float constants can have **fixed precision**

## Constants - Not what you think

.play examples/constants-time.go /^func main/,/^}

## Lets make that better!

.play examples/constants-time-2.go /^func main/,/^}

## Now make it configurable!

.play examples/constants-time-3.go /^func main/,/^}

## What??

`
  ./prog.go:19:28: invalid operation: time.Second * sleepSeconds (mismatched types time.Duration and int)
`

.code examples/constants-time-2.go /BEGIN OMIT/,/END OMIT/
.code examples/constants-time-3.go /BEGIN OMIT/,/END OMIT/

## What Type of Constant is that? None!

.link https://golang.org/ref/spec#Constants

> Constants may be typed or untyped. Literal constants, true, false, iota, and certain constant expressions containing only untyped constant operands are untyped.

> A constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type.

## Untyped consant work

Go effectively does this for us during compilation

.code examples/constants-time-2-behind.go /^func main/,/^}

## Lets do that then!

.play examples/constants-time-4.go /^func main/,/^}

## Interesting Golang Type Discoveriess

1. Bools can be **more than one bit**
1. `int` and `uint` can **change size**
1. Float constants can have **fixed precision**
1. Constants can be **untyped**

## Bytes

Go has a raw data type called `byte` this is actually an alias to the `uint8` type.

Bytes are most commonly used under the hood for strings and
other IO operations we will talk about later

But it is possible to create constants and variables of the byte type which hold ASCII characters.

```go
var numberFromOctal byte = 01
var numberFromHex byte = 0x1
var numberReadable byte = 1_00
var letter byte = 'c'
```

## Arrays

Arrays are swaths of contiguous memory for a specific type. They have a fixed length
and their length cannot be changed after initialization.

## Slices

Slices are a convenience layer on top of arrays, but they are backed by arrays.

Slices really have **two sizes**, the size of the `sliceHeader` and the size of the underlying `array`

When you pass a slice around, you pass a copy of the `sliceHeader` which is essentially a 3-word length
struct that is completely hidden by the language.

Each slice header can be thought of like a struct with the following composition:

```go
type sliceHeader struct {
    ptr *[]Elem
    len int
    cap int
}
```

## Slices - Sizes

.play examples/slices-sizes.go /^func main/,/^}

## Byte Slices

It is the type most often used when dealing with IO operations.
They are also the basic data type that underlies both runes and strings.

## Strings

* Strings are immutable
* Strings are actually backed by byte slices
* Strings are passed by copy of their `sliceHeader`

## String Indexing

Because strings are actually byte slices under the hood, it is very easy to index them.

.play examples/strings-indexing.go /^func main/,/^}

## String Indexing - gotcha!

Strings are `[]byte` under the hood. And can contain non-ASCII data

.play examples/strings-indexing-awry.go /^func main/,/^}

**Add loop example**

## String Indexing - Why did that happen?

* strings are `[]byte`
* non-ASCII characters are made up of multiple bytes

.play examples/strings-indexing-awry-explained.go /^func main/,/^}

## String Indexing - []rune

You can convert to strings to `[]rune` to index 'characters' more reliably

.play examples/strings-indexing-awry-fixed.go /^func main/,/^}

**Add loop example**

## String Indexing - gotcha again!

But even then, strings don't always contain printable bytes.

.play examples/strings-indexing-bytes.go /^func main/,/^}

**Add loop example**


## Runes

* Runes are also backed by byte slices under the hood
* Runes are an alias to the `int32` type
* Runes are the default type used when creating a fuzzy constant with single quotes
    ```go
    r := 'x'
    ```

## Structs

Stucts are the way that go organizes data. They can have zero to N fields.

## Struct Sizes

They are usually as big as their fields combined.

*code example

But not always!

*code example of boolean compression

## Struct Sizes - Simple

.play examples/structs-sizes.go /^func main/,/^}

## Struct Sizes - Complex

.play examples/structs-sizes-complex.go /^func main/,/^}

## Struct Sizes - Padding

.play examples/structs-sizes-padding.go /^func main/,/^}

## Go Spec

Explain that structs must be "naturally" alligned

*Shovel analogy

## Struct Sizes - Padding Natural Alignment

.play examples/structs-sizes-padding-alt.go /^func main/,/^}

## Struct Sizes - Padding Bools

.play examples/structs-sizes-padding-bools.go /^func main/,/^}

## Struct Sizes - Padding Bools Cont.

.play examples/structs-sizes-padding-bools-more.go /^func main/,/^}

## Struct Sizes - Padding Bools Cont.

.play examples/structs-sizes-padding-bools-more-awry.go /^func main/,/^}

## Empty Structs are zero size

.play examples/empty-struct.go /^func main/,/^}

## Empty Structs of all empty members are zero size

.play examples/empty-struct-nested.go /^func main/,/^}

## Empty Struct arrays are zero size

.play examples/empty-struct-array.go /^func main/,/^}

## Empty Struct slices have the sliceHeader size only

This means that slices of empty structs take up **more** memory than arrays of empty structs

.play examples/empty-struct-array.go /^func main/,/^}

## The IMPORTANT Part - Empty struct

Empty structs are most practically used in maps and channels

* This signals to the code reader that the *content* of the map or channel is not important.
* The memory savings in very large maps is also a nice bonus

## Interfaces

Interfaces could hold anything. So they have to be stored as two-word
pairs of data:

* A pointer to information about the type stored in the interface
* A pointer to the associate data

## Interface sizes are always the same

.play examples/interfaces.go /BEGIN OMIT/,/END OMIT/
